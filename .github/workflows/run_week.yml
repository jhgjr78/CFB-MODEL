name: CFB Model — Full Runner (Safe)

on:
  workflow_dispatch:
    inputs:
      year:  { description: "Season year", required: true, default: "2025" }
      week:  { description: "Week number", required: true, default: "6" }
      scope: { description: "top25 or all", required: true, default: "all" }

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }

      - name: Install deps
        run: |
          pip install pandas httpx

      - name: Build Week predictions & publish JSON
        env:
          CFBD_API_KEY: ${{ secrets.CFBD_API_KEY }}
          YEAR: ${{ github.event.inputs.year }}
          WEEK: ${{ github.event.inputs.week }}
          SCOPE: ${{ github.event.inputs.scope }}
        run: |
          python - << 'PY'
          import os, json, asyncio, math
          import pandas as pd
          import httpx
          import traceback

          BASE = "https://api.collegefootballdata.com"
          KEY  = os.getenv("CFBD_API_KEY")
          HEAD = {"Authorization": f"Bearer {KEY}"} if KEY else {}

          YEAR = int(os.getenv("YEAR", "2025"))
          WEEK = int(os.getenv("WEEK", "6"))
          SCOPE= (os.getenv("SCOPE","all") or "all").lower()

          # -------- guardrails / knobs --------
          def clamp(x, lo, hi): 
              try: x=float(x)
              except: x=0.0
              return max(lo, min(hi, x))

          SCALE_PER_0P10 = 2.0
          HFA_DEFAULT    = 2.0
          FINAL_SPREAD_CAP = 32.0
          BASE_EPP       = 0.42 # ~55 pts / 130 plays

          COMP_LIMITS = {"fp":4.0,"hidden":3.0,"xpl":6.0,"sr":4.0,"havoc":3.0,"recency":3.0}
          WEIGHTS     = {k:1.0 for k in COMP_LIMITS}

          def notice(msg): print(f"::notice::{msg}")

          async def jget(client, url, params=None):
              r = await client.get(url, headers=HEAD, params=params or {}, timeout=40)
              r.raise_for_status()
              return r.json()

          async def main():
              try:
                  async with httpx.AsyncClient(base_url=BASE) as client:
                      notice("1/7 games…")
                      games = await jget(client, "/games", {"year": YEAR, "week": WEEK, "seasonType":"regular"})
                      gdf = pd.DataFrame(games)
                      if gdf.empty:
                          os.makedirs("docs", exist_ok=True)
                          open("docs/week_preds.json","w").write("[]")
                          pd.DataFrame().to_csv("week_preds.csv", index=False)
                          return

                      # Rankings filter (top25)
                      if SCOPE == "top25":
                          notice("2/7 rankings…")
                          ranks = await jget(client, "/rankings", {"year": YEAR, "week": WEEK})
                          ap=set()
                          for wk in ranks:
                              for poll in wk.get("polls",[]):
                                  if (poll.get("poll") or "").startswith("AP"):
                                      ap |= {t.get("school") for t in poll.get("ranks",[]) if t.get("school")}
                          gdf = gdf[gdf["homeTeam"].isin(ap) | gdf["awayTeam"].isin(ap)]
                          if gdf.empty:
                              os.makedirs("docs", exist_ok=True)
                              open("docs/week_preds.json","w").write("[]")
                              pd.DataFrame().to_csv("week_preds.csv", index=False)
                              return

                      teams = sorted(set(gdf["homeTeam"]).union(gdf["awayTeam"]))

                      # PPA
                      notice("3/7 PPA…")
                      ppa = await jget(client, "/ppa/teams", {"year": YEAR})
                      off_map, def_map = {}, {}
                      for row in ppa:
                          t=row.get("team")
                          off=(row.get("offense") or {})
                          deff=(row.get("defense") or {})
                          o = off.get("overall", off.get("ppa", 0.0)) or 0.0
                          d = deff.get("overall", deff.get("ppa", 0.0)) or 0.0
                          if t in teams:
                              try: off_map[t]=float(o)
                              except: off_map[t]=0.0
                              try: def_map[t]=float(d)
                              except: def_map[t]=0.0

                      # stats (off/def/special)
                      notice("4/7 season stats…")
                      async def team_stats(team):
                          cats = ["offense","defense","special"]
                          async def one(cat):
                              try:
                                  rows = await jget(client, "/stats/season", {"year": YEAR, "team": team, "category": cat})
                              except Exception:
                                  rows=[]
                              m={}
                              for r in rows:
                                  n=(r.get("statName") or r.get("stat_name") or "").lower()
                                  v=r.get("statValue") or r.get("stat_value")
                                  try: v=float(v)
                                  except: 
                                      try: v=int(v)
                                      except: v=None
                                  if v is not None:
                                      m[n]=v
                              return cat, m
                          pairs = await asyncio.gather(*(one(c) for c in cats))
                          return team, {k:v for k,v in pairs}
                      stats = dict(await asyncio.gather(*(team_stats(t) for t in teams)))

                      # drives (field position)
                      notice("5/7 drives…")
                      drives_team = {t:{"osfp":25.0,"dsfp":25.0} for t in teams}
                      async def osfp_for(team):
                          try:
                              drv = await jget(client, "/drives", {"year": YEAR, "week": WEEK, "team": team})
                              vals=[100 - d.get("start_yards_to_goal") for d in drv if d.get("start_yards_to_goal") is not None]
                              v = sum(vals)/len(vals) if vals else 25.0
                          except Exception: v = 25.0
                          drives_team[team]["osfp"]=float(v)
                      await asyncio.gather(*(osfp_for(t) for t in teams))
                      # dsfp (lightweight; not critical if missing)
                      try:
                          drv_all = await jget(client, "/drives", {"year": YEAR, "week": WEEK})
                          per_def = {t:[] for t in teams}
                          for d in drv_all:
                              t = d.get("defense")
                              if t in per_def and d.get("start_yards_to_goal") is not None:
                                  per_def[t].append(100 - d["start_yards_to_goal"])
                          for t,vals in per_def.items():
                              drives_team[t]["dsfp"] = float(sum(vals)/len(vals)) if vals else 25.0
                      except Exception:
                          pass

                      # vegas
                      notice("6/7 vegas lines…")
                      lines = await jget(client, "/lines", {"year": YEAR, "week": WEEK, "seasonType":"regular"})
                      v_map={}
                      for ln in lines or []:
                          home = ln.get("homeTeam"); away=ln.get("awayTeam")
                          for b in (ln.get("lines") or []):
                              sp=b.get("spread"); to=b.get("overUnder")
                              if home and away:
                                  v_map.setdefault((home,away), []).append((sp,to))
                      vegas={}
                      for k,vals in v_map.items():
                          s=[float(v) for v,_ in vals if isinstance(v,(int,float))]
                          t=[float(u) for _,u in vals if isinstance(u,(int,float))]
                          vegas[k]={"vegas_spread": round(sum(s)/len(s),1) if s else None,
                                    "vegas_total":  round(sum(t)/len(t),1) if t else None}

                      # ---------- feature helpers ----------
                      def safe_stats(team, cat):
                          return stats.get(team, {}).get(cat, {}) or {}

                      def plays_per_game(m):
                          plays = m.get("plays"); g = m.get("games") or m.get("gp") or m.get("gms")
                          try: return float(plays)/float(g) if plays and g else None
                          except: return None

                      def pace_total(h,a):
                          ph = plays_per_game(safe_stats(h,"offense")) or 65.0
                          pa = plays_per_game(safe_stats(a,"offense")) or 65.0
                          return ph + pa

                      def pace_scale(x, total_plays, baseline=130.0, elasticity=0.25):
                          return float(x)*(1.0 + elasticity*((float(total_plays)-baseline)/baseline))

                      def fp_points(h,a, pts_per_yd=0.06):
                          os_h = drives_team[h]["osfp"]; ds_h = drives_team[h]["dsfp"]
                          os_a = drives_team[a]["osfp"]; ds_a = drives_team[a]["dsfp"]
                          exp_h = 0.5*os_h + 0.5*ds_a
                          exp_a = 0.5*os_a + 0.5*ds_h
                          return (exp_h-exp_a)*pts_per_yd

                      def hidden_yards(h,a, pts_per_yd=0.055):
                          sh = safe_stats(h,"special"); sa = safe_stats(a,"special")
                          net_h = float(sh.get("netpunting", 0) or 0)
                          net_a = float(sa.get("netpunting", 0) or 0)
                          return (net_h - net_a) * pts_per_yd

                      def sr_val(m):
                          for k,v in m.items():
                              if "success" in k and ("%" in k or "rate" in k):
                                  try:
                                      v=float(v); 
                                      return v/100.0 if v>1 else v
                                  except:
                                      pass
                          return None

                      def success_points(h,a, scale_per_5pct=1.2):
                          oh = sr_val(safe_stats(h,"offense")); ad = sr_val(safe_stats(a,"defense"))
                          oa = sr_val(safe_stats(a,"offense")); hd = sr_val(safe_stats(h,"defense"))
                          pts=0.0
                          if oh is not None and ad is not None: pts += ((oh-ad)/0.05)*scale_per_5pct
                          if oa is not None and hd is not None: pts -= ((oa-hd)/0.05)*scale_per_5pct
                          return pts

                      def explosiveness_points(h,a):
                          oh = off_map.get(h,0.0); da = def_map.get(a,0.0)
                          oa = off_map.get(a,0.0); dh = def_map.get(h,0.0)
                          return ((oh-da)-(oa-dh))/0.10 * SCALE_PER_0P10

                      def havoc_points(h,a, scale=2.0):
                          dh = safe_stats(h,"defense"); da = safe_stats(a,"defense")
                          oh = safe_stats(h,"offense"); oa = safe_stats(a,"offense")
                          def safe(v): 
                              try: return float(v or 0)
                              except: return 0.0
                          def rate(d,o):
                              tfl = safe(d.get("tfl", d.get("tacklesforloss")))
                              sacks = safe(d.get("sacks"))
                              plays = safe(d.get("plays")) or 1.0
                              sacks_allowed = safe(o.get("sacksallowed"))
                              return (tfl + 0.5*sacks + 0.5*sacks_allowed) / plays
                          try:
                              return (rate(dh,oa) - rate(da,oh)) * scale
                          except Exception:
                              return 0.0

                      def team_epp(off_ppa, opp_def_ppa):
                          return clamp(BASE_EPP + (float(off_ppa) - float(opp_def_ppa)), 0.12, 0.65)

                      def predict_total_pts(plays, off_h, def_a, off_a, def_h, xpl, sr):
                          epp_h = team_epp(off_h, def_a)
                          epp_a = team_epp(off_a, def_h)
                          total = epp_h*(plays/2.0) + epp_a*(plays/2.0)
                          total += 0.5*(xpl + sr)
                          return clamp(total, 30, 95)

                      # ---------- compute ----------
                      notice("7/7 compute spreads/totals…")
                      out=[]
                      for _, g in gdf.iterrows():
                          h, a = g["homeTeam"], g["awayTeam"]
                          HFA = HFA_DEFAULT if not bool(g.get("neutralSite")) else 0.5

                          base = explosiveness_points(h,a) + HFA
                          plays = pace_total(h,a)

                          xpl_raw = pace_scale(explosiveness_points(h,a), plays)
                          sr_raw  = pace_scale(success_points(h,a), plays)
                          hv_raw  = pace_scale(havoc_points(h,a), plays)
                          fp_raw  = fp_points(h,a)
                          hy_raw  = hidden_yards(h,a)
                          rcy_raw = 0.0  # recency disabled for safety; we’ll re-enable later

                          def cap(n,v): return clamp(v*WEIGHTS[n], -COMP_LIMITS[n], COMP_LIMITS[n])
                          fp  = cap("fp", fp_raw);  hy  = cap("hidden", hy_raw)
                          xpl = cap("xpl", xpl_raw); sr  = cap("sr", sr_raw)
                          hv  = cap("havoc", hv_raw); rcy = cap("recency", rcy_raw)

                          adj = clamp(base + fp + hy + xpl + sr + hv + rcy, -FINAL_SPREAD_CAP, FINAL_SPREAD_CAP)

                          total_pts = predict_total_pts(
                              plays=plays,
                              off_h=off_map.get(h,0.0), def_a=def_map.get(a,0.0),
                              off_a=off_map.get(a,0.0), def_h=def_map.get(h,0.0),
                              xpl=xpl, sr=sr
                          )

                          # Vegas priors (if available)
                          v = vegas.get((h,a), {})
                          if v.get("vegas_spread") is not None:
                              adj = 0.8*adj + 0.2*float(v["vegas_spread"])
                          if v.get("vegas_total") is not None:
                              total_pts = 0.85*total_pts + 0.15*float(v["vegas_total"])

                          home_pts = max(0, int(round((total_pts + adj)/2.0)))
                          away_pts = max(0, int(round(total_pts - home_pts)))
                          fav = h if adj >= 0 else a

                          out.append({
                              "home":h,"away":a,"favored":fav,
                              "base_spread": round(base,1),
                              "adj_spread":  round(adj,1),
                              "home_pts": home_pts, "away_pts": away_pts,
                              "total_pts": int(round(total_pts)),
                              "vegas_spread": v.get("vegas_spread"), "vegas_total": v.get("vegas_total"),
                              "plays_est": int(round(plays)),
                              "fp": round(fp,2), "hidden": round(hy,2),
                              "xpl": round(xpl,2), "sr": round(sr,2),
                              "havoc": round(hv,2), "recency": round(rcy,2)
                          })

                      out = sorted(out, key=lambda r: abs(r["adj_spread"]), reverse=True)
                      pd.DataFrame(out).to_csv("week_preds.csv", index=False)
                      os.makedirs("docs", exist_ok=True)
                      with open("docs/week_preds.json","w",encoding="utf-8") as f:
                          json.dump(out, f, ensure_ascii=False)

              except Exception as e:
                  print("::error::Pipeline crashed")
                  traceback.print_exc()
                  raise

          asyncio.run(main())
          PY

      - name: Commit JSON to docs (for Pages)
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs/week_preds.json
          git commit -m "Publish week_preds.json" || echo "No changes"
          git push

      - name: Upload CSV artifact
        uses: actions/upload-artifact@v4
        with:
          name: week_preds
          path: week_preds.csv