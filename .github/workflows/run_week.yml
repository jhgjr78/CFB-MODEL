name: CFB Model â€” Full Runner

on:
  workflow_dispatch:
    inputs:
      year:  { description: "Season year", required: true, default: "2025" }
      week:  { description: "Week number", required: true, default: "6" }
      scope: { description: "top25 or all", required: true, default: "all" }

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }

      - name: Install deps
        run: |
          pip install pandas httpx

      - name: Build Week predictions & publish JSON
        env:
          CFBD_API_KEY: ${{ secrets.CFBD_API_KEY }}
          YEAR: ${{ github.event.inputs.year }}
          WEEK: ${{ github.event.inputs.week }}
          SCOPE: ${{ github.event.inputs.scope }}
          MODE: "FULL"
        run: |
          python - << 'PY'
          import os, json, asyncio, pandas as pd, httpx

          BASE = "https://api.collegefootballdata.com"
          KEY  = os.getenv("CFBD_API_KEY")
          HEAD = {"Authorization": f"Bearer {KEY}"} if KEY else {}

          YEAR = int(os.getenv("YEAR","2025"))
          WEEK = int(os.getenv("WEEK","6"))
          SCOPE= (os.getenv("SCOPE","all") or "all").lower()
          MODE = (os.getenv("MODE","FULL") or "FULL").upper()

          # ---------------- CONFIG / GUARDRAILS ----------------
          SCALE_PER_0P10 = 2.0
          HFA_DEFAULT = 2.0
          FINAL_SPREAD_CAP = 32.0
          BASE_EPP = 0.42

          COMP_LIMITS = {
            "fp": 4.0, "hidden": 3.0, "xpl": 6.0,
            "sr": 4.0, "havoc": 3.0, "recency": 3.0
          }
          WEIGHTS = {k:1.0 for k in COMP_LIMITS}

          def clamp(x, lo, hi): return max(lo, min(hi, x))

          # ---------------- ASYNC FETCH ----------------
          async def jget(client, url, params=None):
            r = await client.get(url, headers=HEAD, params=params or {}, timeout=40)
            r.raise_for_status()
            return r.json()

          async def main():
            async with httpx.AsyncClient(base_url=BASE) as client:

              # 1) Games
              games = await jget(client, "/games", {"year": YEAR, "week": WEEK, "seasonType":"regular"})
              gdf = pd.DataFrame(games)
              if gdf.empty:
                os.makedirs("docs", exist_ok=True)
                open("docs/week_preds.json","w").write("[]")
                pd.DataFrame().to_csv("week_preds.csv", index=False)
                return

              # 2) Rankings filter (if top25)
              if SCOPE == "top25":
                ranks = await jget(client, "/rankings", {"year": YEAR, "week": WEEK})
                ap=set()
                for wk in ranks:
                  for poll in wk.get("polls",[]):
                    if (poll.get("poll") or "").startswith("AP"):
                      ap |= {t.get("school") for t in poll.get("ranks",[]) if t.get("school")}
                gdf = gdf[gdf["homeTeam"].isin(ap) | gdf["awayTeam"].isin(ap)]
                if gdf.empty:
                  os.makedirs("docs", exist_ok=True)
                  open("docs/week_preds.json","w").write("[]")
                  pd.DataFrame().to_csv("week_preds.csv", index=False)
                  return

              teams = sorted(set(gdf["homeTeam"]).union(gdf["awayTeam"]))

              # 3) PPA
              ppa = await jget(client, "/ppa/teams", {"year": YEAR})
              off_map, def_map = {}, {}
              for row in ppa:
                t=row.get("team")
                off=((row.get("offense") or {}).get("overall") or (row.get("offense") or {}).get("ppa") or 0.0) or 0.0
                deff=((row.get("defense") or {}).get("overall") or (row.get("defense") or {}).get("ppa") or 0.0) or 0.0
                if t in teams:
                  off_map[t]=float(off); def_map[t]=float(deff)

              # 4) Stats (off/def/special)
              async def team_stats(team):
                cats = ["offense","defense","special"]
                async def one(cat):
                  try:
                    rows = await jget(client, "/stats/season", {"year": YEAR, "team": team, "category": cat})
                  except Exception: rows=[]
                  m={}
                  for r in rows:
                    n=(r.get("statName") or r.get("stat_name") or "").lower()
                    v=r.get("statValue") or r.get("stat_value")
                    try: v=float(v)
                    except: pass
                    m[n]=v
                  return cat, m
                pairs = await asyncio.gather(*(one(c) for c in cats))
                return team, {k:v for k,v in pairs}
              stats = dict(await asyncio.gather(*(team_stats(t) for t in teams)))

              # 5) Field position
              drives_team = {t:{"osfp":25.0,"dsfp":25.0} for t in teams}
              if MODE=="FULL":
                async def team_osfp(team):
                  try:
                    drv = await jget(client, "/drives", {"year": YEAR, "week": WEEK, "team": team})
                    vals=[100 - d.get("start_yards_to_goal") for d in drv if d.get("start_yards_to_goal") is not None]
                    osfp = sum(vals)/len(vals) if vals else 25.0
                  except: osfp = 25.0
                  drives_team[team]["osfp"]=osfp
                await asyncio.gather(*(team_osfp(t) for t in teams))

              # 6) Vegas
              lines = await jget(client, "/lines", {"year": YEAR, "week": WEEK, "seasonType":"regular"})
              v_map={}
              for ln in lines or []:
                home = ln.get("homeTeam"); away=ln.get("awayTeam")
                for b in (ln.get("lines") or []):
                  sp=b.get("spread"); to=b.get("overUnder")
                  if home and away:
                    v_map.setdefault((home,away), []).append((sp,to))
              vegas={}
              for k,vals in v_map.items():
                s=[v for v,_ in vals if isinstance(v,(int,float))]
                t=[u for _,u in vals if isinstance(u,(int,float))]
                vegas[k]={"vegas_spread": round(sum(s)/len(s),1) if s else None,
                          "vegas_total": round(sum(t)/len(t),1) if t else None}

              # -------- feature fns --------
              def pace_total(h,a):
                def ppg(m):
                  plays=m.get("plays"); g=m.get("games") or m.get("gp") or m.get("gms")
                  try: return float(plays)/float(g) if plays and g else None
                  except: return None
                return (ppg(stats[h]["off"]) or 65)+(ppg(stats[a]["off"]) or 65)

              def pace_scale(x, total_plays, baseline=130.0, elasticity=0.25):
                return x*(1.0 + elasticity*((total_plays-baseline)/baseline))

              def fp_points(h,a, pts_per_yd=0.06):
                exp_h=0.5*drives_team[h]["osfp"]+0.5*drives_team[a]["dsfp"]
                exp_a=0.5*drives_team[a]["osfp"]+0.5*drives_team[h]["dsfp"]
                return (exp_h-exp_a)*pts_per_yd

              def hidden_yards(h,a, pts_per_yd=0.055):
                sh,sa=stats[h].get("special",{}),stats[a].get("special",{})
                net_h=sh.get("netpunting",0) or 0
                net_a=sa.get("netpunting",0) or 0
                return (net_h-net_a)*pts_per_yd

              def _get_sr(m):
                for k,v in m.items():
                  if "success" in k and ("%" in k or "rate" in k):
                    try: return float(v)/100 if float(v)>1 else float(v)
                    except: pass
                return None
              def success_points(h,a, scale_per_5pct=1.2):
                sh_off=_get_sr(stats[h]["off"]); sa_def=_get_sr(stats[a]["def"])
                sa_off=_get_sr(stats[a]["off"]); sh_def=_get_sr(stats[h]["def"])
                pts=0
                if sh_off and sa_def: pts+=((sh_off-sa_def)/0.05)*scale_per_5pct
                if sa_off and sh_def: pts-=((sa_off-sh_def)/0.05)*scale_per_5pct
                return pts

              def explosiveness_points(h,a): 
                return ((off_map.get(h,0)-def_map.get(a,0))-
                        (off_map.get(a,0)-def_map.get(h,0)))/0.10*SCALE_PER_0P10

              def havoc_points(h,a, scale=2.0):
                dh,da,oh,oa=stats[h]["def"],stats[a]["def"],stats[h]["off"],stats[a]["off"]
                def safe(v): 
                    try:return float(v or 0)
                    except:return 0
                def rate(d,o):
                    tfl=safe(d.get("tfl",d.get("tacklesforloss")))+safe(d.get("sacks"))
                    plays=safe(d.get("plays")) or 1
                    sacks_allowed=safe(o.get("sacksallowed"))
                    return (tfl+0.5*sacks_allowed)/plays
                try: return (rate(dh,oa)-rate(da,oh))*scale
                except: return 0

              async def recency_points(h,a,n=4,scale=0.5):
                def diff(team):
                  try:
                    gt = asyncio.run(jget(client,"/games/teams",{"year":YEAR,"team":team,"seasonType":"regular"}))
                  except: return 0
                  rows=[(g.get("pointsFor"),g.get("pointsAgainst")) for g in gt if g.get("week",99)<WEEK][-n:]
                  return sum((pf-pa) for pf,pa in rows)/len(rows) if rows else 0
                return (diff(h)-diff(a))*scale

              def team_epp(off_ppa, opp_def_ppa): 
                return clamp(BASE_EPP+(off_ppa-opp_def_ppa),0.12,0.65)

              def predict_total_pts(plays,off_h,def_a,off_a,def_h,xpl,sr):
                epp_h=team_epp(off_h,def_a); epp_a=team_epp(off_a,def_h)
                total=epp_h*(plays/2)+epp_a*(plays/2)
                total+=0.5*(xpl+sr)
                return clamp(total,30,95)

              # 7) compute
              out=[]
              for _,g in gdf.iterrows():
                h,a=g["homeTeam"],g["awayTeam"]

                HFA=HFA_DEFAULT if not bool(g.get("neutralSite")) else 0.5
                base=explosiveness_points(h,a)+HFA

                plays=pace_total(h,a)
                xpl_raw=pace_scale(explosiveness_points(h,a),plays)
                sr_raw =pace_scale(success_points(h,a),plays)
                hv_raw =pace_scale(havoc_points(h,a),plays)
                fp_raw =fp_points(h,a)
                hy_raw =hidden_yards(h,a)

                rcy_raw=0 # simplify; recency async stubbed

                def cap(n,v): return clamp(v*WEIGHTS[n],-COMP_LIMITS[n],COMP_LIMITS[n])
                fp,hy,xpl,sr,hv,rcy=[cap(n,v) for n,v in
                  [("fp",fp_raw),("hidden",hy_raw),("xpl",xpl_raw),
                   ("sr",sr_raw),("havoc",hv_raw),("recency",rcy_raw)]]

                adj=clamp(base+fp+hy+xpl+sr+hv+rcy,-FINAL_SPREAD_CAP,FINAL_SPREAD_CAP)

                total_pts=predict_total_pts(plays,off_map.get(h,0),def_map.get(a,0),
                                             off_map.get(a,0),def_map.get(h,0),xpl,sr)

                # Vegas prior
                v=vegas.get((h,a),{})
                if v.get("vegas_spread") is not None:
                  adj=0.8*adj+0.2*float(v["vegas_spread"])
                if v.get("vegas_total") is not None:
                  total_pts=0.85*total_pts+0.15*float(v["vegas_total"])

                home_pts=max(0,int(round((total_pts+adj)/2)))
                away_pts=max(0,int(round(total_pts-home_pts)))
                fav=h if adj>=0 else a

                out.append({
                  "home":h,"away":a,"favored":fav,
                  "base_spread":round(base,1),
                  "adj_spread":round(adj,1),
                  "home_pts":home_pts,"away_pts":away_pts,
                  "total_pts":int(total_pts),
                  "vegas_spread":v.get("vegas_spread"),"vegas_total":v.get("vegas_total"),
                  "plays_est":int(round(plays)),
                  "fp":round(fp,2),"hidden":round(hy,2),
                  "xpl":round(xpl,2),"sr":round(sr,2),
                  "havoc":round(hv,2),"recency":round(rcy,2)
                })

              out=sorted(out,key=lambda r:abs(r["adj_spread"]),reverse=True)
              pd.DataFrame(out).to_csv("week_preds.csv",index=False)
              os.makedirs("docs",exist_ok=True)
              with open("docs/week_preds.json","w") as f: json.dump(out,f)

          asyncio.run(main())
          PY

      - name: Commit JSON to docs (for Pages)
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs/week_preds.json
          git commit -m "Publish week_preds.json" || echo "No changes"
          git push

      - name: Upload CSV artifact
        uses: actions/upload-artifact@v4
        with:
          name: week_preds
          path: week_preds.csv